import{_ as i,c as n,aA as l,G as o,B as t,o as c}from"./chunks/framework.BKWMtcQE.js";const w=JSON.parse('{"title":"使用public代码","description":"","frontmatter":{},"headers":[],"relativePath":"devtool/public_code.md","filePath":"devtool/public_code.md","lastUpdated":1740105376000}'),r={name:"devtool/public_code.md"};function s(p,e,u,h,g,b){const a=t("NolebaseGitContributors"),d=t("NolebaseGitChangelog");return c(),n("div",null,[e[0]||(e[0]=l('<h1 id="使用public代码" tabindex="-1">使用<code>public</code>代码 <a class="header-anchor" href="#使用public代码" aria-label="Permalink to &quot;使用`public`代码&quot;">​</a></h1><p>工具目录<code>tool</code>下还有一个<code>public</code>目录，这里存放的是公共代码，存放在此是为了与工具箱本体的代码做区分，并且方便工具导入。</p><p>使用<code>public</code>代码可以加速开发外表美观的工具，比如，使用<code>public_window.FanWindow</code>可以快速创建一个拥有空白窗口的空白工具。创建出的窗口与芒果工具箱本体窗口是风格一致、亮暗一致的，<a href="/devtool/structure.html">工具结构</a>中给出的第一种创建窗口的方法就是使用了<code>FanWindow</code>来快速创建。此外，您也可以从<code>PySide6</code>和<code>qfluentwidgets</code>中导入各种组件或对象来设计窗口。</p><p>或者也可以直接使用设计师+UIC来创建窗口，但是请参见下面的注意事项。</p><div class="warning custom-block"><p class="custom-block-title">⚠️注意！</p><p>PySide6原生的设计师和UIC工具设计的、使用Qt原生组件的窗口，需要在实例化时继承PySide6的原生窗口类，而不建议继承<code>public</code>中提供的<code>FanWindow</code>。</p><p>这是因为当<code>FanWindow</code>切换亮暗主题时，原生的Qt组件并不能与之一同切换主题，从而导致在暗色下组件几乎完全不可见。</p><p>解决方案一：使用安装了QFluentWidgets插件的设计师（Fluent Client），参见<a href="https://qfluentwidgets.com/zh/pages/designer" target="_blank" rel="noreferrer">QFluentWidgets指南</a>。</p><p>解决方案二：在设计师中提升控件，但不能直接在设计师中预览设计效果，还是参见<a href="https://qfluentwidgets.com/zh/pages/designer" target="_blank" rel="noreferrer">上面的指南</a>。</p><p>解决方案三：手写UI，QFluentWidgets的控件的使用方式与Qt原生控件几乎一致，请参见<a href="https://qfluentwidgets.com/zh/pages/about" target="_blank" rel="noreferrer">QFluentWidgets文档</a>。</p><p>解决方案四：使用Qt原生组件+Qt原生窗口，这样创建的窗口不支持工具箱的亮暗主题切换，美观程度会下降，但能够使用原生的设计师和UIC工具。</p></div><p>另外，如果您使用Pycharm，可以参考我的这篇文章：<a href="https://ifanspace.top/2025/01/26/599.html" target="_blank" rel="noreferrer">为Pycharm添加PySide6外部工具的进阶教程</a>。</p><h2 id="function" tabindex="-1">function <a class="header-anchor" href="#function" aria-label="Permalink to &quot;function&quot;">​</a></h2><h3 id="gettooldir" tabindex="-1">getToolDir <a class="header-anchor" href="#gettooldir" aria-label="Permalink to &quot;getToolDir&quot;">​</a></h3><p>获取工具目录。</p><p>此方法有几个重载，传入工具名后可以获得传入的工具名的所在目录，预计未来还会继续重载几个吧。</p><h2 id="public-window" tabindex="-1">public_window <a class="header-anchor" href="#public-window" aria-label="Permalink to &quot;public_window&quot;">​</a></h2><p>提供与工具箱本体一家的<code>FanWindow</code>窗口类，经过芒果的轻度魔改。</p><p>只有<code>launchMode</code>为0的工具才能调用这里的窗口类……</p><h3 id="fanwindow" tabindex="-1">FanWindow <a class="header-anchor" href="#fanwindow" aria-label="Permalink to &quot;FanWindow&quot;">​</a></h3><p>PySide6 * QFluentWidgets 窗口，用法非常简单合理。</p><p>只能使用QFluentWidgets组件填充在<code>FanWindow</code>内，例如将<code>QLabel</code>更换成QFluentWidgets中的<code>Label</code>家族的成员，将<code>QPushButton</code>换成QFluentWidgets中的<code>PushButton</code>与它的家人们。您也可以使用QFluentWidgets Pro中的组件，工具箱本体能够运行这些Pro版组件。</p><p>查看<a href="https://qfluentwidgets.com/zh/" target="_blank" rel="noreferrer">QFluentWidgets的文档</a>来入门这款Win11风格的PyQt/PySide组件库。</p><p>轻度魔改体现在哪里呢？<code>FanWindow</code>计划同时支持Windows11的云母效果与Windows10的亚克力效果，与芒果工具箱的主窗口同步。另外，<code>FanWindow</code>还提供一个<code>windowResizeSignal</code>信号，会在窗口大小变化时触发。</p><h2 id="qfluentwidgetsfanaddons" tabindex="-1">qfluentwidgetsfanaddons <a class="header-anchor" href="#qfluentwidgetsfanaddons" aria-label="Permalink to &quot;qfluentwidgetsfanaddons&quot;">​</a></h2><p>如果 <code>public_window</code> 是轻度魔改，这里就是中重度的魔改了，以至于我认为有必要单独分一个模块出来给它，并且起了一个（看起来）非常厉害的名字。</p><p>是针对 PySide6 下 QFluentWidgets 与其 Pro 组件库的功能扩展，目前同样处于早期开发阶段，主要针对工具箱部分组件的需要而设计，未来有发布至 pypi 的打算。</p><p>由于 qfluentwidgetsfanaddons 目前不在重点开发，下面提供的描述仅供参考，可以在工具箱的工具目录 <code>public/qfluentwidgetsfanaddons</code> 中查看源码。</p><h3 id="line-widget" tabindex="-1">line_widget <a class="header-anchor" href="#line-widget" aria-label="Permalink to &quot;line_widget&quot;">​</a></h3><h4 id="fanroundlistwidget" tabindex="-1">FanRoundListWidget <a class="header-anchor" href="#fanroundlistwidget" aria-label="Permalink to &quot;FanRoundListWidget&quot;">​</a></h4><p>RoundListWidget 是 Pro 组件。FanRoundListWidget 在 RoundListWidget 的基础上简化了右键菜单的设置，可以通过简单的 <code>setRightClickMenu()</code> 来设置右键菜单。</p><p>该函数接收两个参数，可以是两个菜单对象（<code>RoundMenu</code> 或 <code>QMenu</code>），也可以是一个菜单与一个右键菜单模式。</p><p>正在开发的翻译家工具的主窗口中使用了 FanRoundListWidget，可以查看其用法。</p><h3 id="card-widget" tabindex="-1">card_widget <a class="header-anchor" href="#card-widget" aria-label="Permalink to &quot;card_widget&quot;">​</a></h3><h4 id="clickablecardwidget" tabindex="-1">ClickableCardWidget <a class="header-anchor" href="#clickablecardwidget" aria-label="Permalink to &quot;ClickableCardWidget&quot;">​</a></h4><p>可点击选中的卡片组件，用来实现有复杂需求的列表。</p><p>可以设置卡片可选中，需要设置选中后的颜色。将若干卡片添加到 ScrollArea 中，并自行连接信号，可以实现在一张卡片被点击时选中该卡片，同时取消选中其他卡片。</p>',31)),o(a),o(d)])}const _=i(r,[["render",s]]);export{w as __pageData,_ as default};
